### Overview

- [æ‰©å±•æ–‡ä»¶(Extension Files)](#æ‰©å±•æ–‡ä»¶Extension-Files)
  - [æ–‡ä»¶å¼•ç”¨(Referring to files)](#æ–‡ä»¶å¼•ç”¨Referring-to-files)
- [æ¶æ„(Architecture)](#æ¶æ„architecture)
  - [Background Script](#Background-Script)
  - [UI Elements](#UI-Elements)
  - [Content Script](#Content-Script)
  - [Options Page](#Options-Page)
- [Using Chrome APIs](#Using-Chrome-APIs)
  - [åŒæ­¥å¼‚æ­¥æ–¹æ³•å¯¹æ¯”(Asynchronous vs. synchronous methods)](#Asynchronous-vs.-synchronous-methods)
  - [æ›´å¤šç»†èŠ‚(More details)](#More-details)


æ‰©å±•æ˜¯ web å¹³å°ä¸­ä½¿ç”¨çš„ HTMLã€CSSã€JavaScriptã€å›¾åƒå’Œå…¶ä»–æ–‡ä»¶çš„å‹ç¼©åŒ…ï¼Œç”¨äºå®šåˆ¶ Google Chrome çš„æµè§ˆä½“éªŒã€‚æ‰©å±•æ˜¯ä½¿ç”¨ web æŠ€æœ¯æ„å»ºçš„ï¼Œå¯ä»¥ä½¿ç”¨æµè§ˆå™¨æä¾›ç»™å¼€æ”¾ web çš„ç›¸åŒ apiã€‚

> Extensions are zipped bundles of HTML, CSS, JavaScript, images, and other files used in the web platform, that customize the Google Chrome browsing experience. Extensions are built using web technology and can use the same APIs the browser provides to the open web.

æ‰©å±•å…·æœ‰å¹¿æ³›çš„åŠŸèƒ½å¯å¡‘æ€§ã€‚å®ƒä»¬å¯ä»¥ä¿®æ”¹ç”¨æˆ·çœ‹åˆ°çš„ web å†…å®¹ï¼Œå¹¶ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’ã€æ‰©å±•å’Œæ›´æ”¹æµè§ˆå™¨æœ¬èº«çš„è¡Œä¸ºã€‚

> Extensions have a wide range of functional possibilities. They can modify web content users see and interact with or extend and change the behavior of the browser itself.

æ‰©å±•è¢«çœ‹ä½œæ˜¯ Chrome æ‰“é€ æˆæœ€ä¸ªæ€§åŒ–æµè§ˆå™¨çš„å¤§é—¨.

> Consider extensions the gateway to making the Chrome browser the most personalized browser.

#### æ‰©å±•æ–‡ä»¶(Extension Files)

æ‰©å±•ååœ¨æ–‡ä»¶ç±»å‹å’Œç›®å½•æ•°é‡ä¸Šæœ‰æ‰€ä¸åŒï¼Œä½†å®ƒä»¬éƒ½éœ€è¦æœ‰æ¸…å•ã€‚ä¸€äº›åŸºæœ¬ä½†æœ‰ç”¨çš„æ‰©å±•å¯èƒ½åªåŒ…å«æ¸…å•åŠå…¶å·¥å…·æ å›¾æ ‡ã€‚

> Extensions vary in types of files and amount of directories, but they are all required to have a **manifest**. Some basic, but useful, extensions may consist of just the manifest and its toolbar icon.

åä¸º manifest.json çš„æ¸…å•æ–‡ä»¶å‘æµè§ˆå™¨æä¾›æœ‰å…³æ‰©å±•åçš„ä¿¡æ¯ï¼Œä¾‹å¦‚æœ€é‡è¦çš„æ–‡ä»¶å’Œæ‰©å±•åå¯èƒ½ä½¿ç”¨çš„åŠŸèƒ½ã€‚

> The manifest file, titled **manifest.json**, gives the browser information about the extension, such as the most important files and the capabilities the extension might use.

```json
{
  "name": "My Extension",
  "version": "2.1",
  "description": "Gets information from Google.",
  "icons": {
    "128": "icon_16.png",
    "128": "icon_32.png",
    "128": "icon_48.png",
    "128": "icon_128.png"
  },
  "background": {
    "persistent": false,
    "scripts": ["background_script.js"]
  },
  "permissions": ["https://*.google.com/", "activeTab"],
  "browser_action": {
    "default_icon": "icon_16.png",
    "default_popup": "popup.html"
  }
}
```

æ‰©å±•å¿…é¡»æœ‰ä¸€ä¸ªä½äºæµè§ˆå™¨å·¥å…·æ ä¸­çš„å›¾æ ‡ã€‚å·¥å…·æ å›¾æ ‡å…è®¸ç®€å•çš„è®¿é—®å¹¶è®©ç”¨æˆ·çŸ¥é“å®‰è£…äº†å“ªäº›æ‰©å±•ã€‚å¤§å¤šæ•°ç”¨æˆ·å°†é€šè¿‡ç‚¹å‡»å›¾æ ‡ä½¿ç”¨å¼¹çª—æ¥å’Œæ‰©å±•è¿›è¡Œäº¤äº’ã€‚

> Extensions must have an icon that sits in the browser toolbar. Toolbar icons allow easy access and keep users aware of which extensions are installed. Most users will interact with an extension that uses a popup by clicking on the icon.

|                                                                            |                                                                    |
| -------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| ![](https://developer.chrome.com/static/images/overview/browser_arrow.png) | ![](https://developer.chrome.com/static/images/overview/mappy.png) |
| This Google Mail Checker extension uses a browser action.                  | This Mappy extension uses a page action and content script.        |

##### æ–‡ä»¶å¼•ç”¨(Referring to files)

æ‰©å±•çš„æ–‡ä»¶å¯ä»¥é€šè¿‡ä½¿ç”¨ç›¸å¯¹è·¯å¾„æ¥å¼•ç”¨ï¼Œå°±åƒæ™®é€š HTML é¡µé¢ä¸­çš„æ–‡ä»¶ä¸€æ ·ã€‚

> An extension's files can be referred to by using a relative URL, just as files in an ordinary HTML page.

```html
<img src="images/my_image.png" />
```
æ­¤å¤–ï¼Œæ¯ä¸ªæ–‡ä»¶ä¹Ÿå¯ä»¥ä½¿ç”¨ç»å¯¹è·¯å¾„è¿›è¡Œå…¥è®¿é—®
>Additionally, each file can also be accessed using an absolute URL.

```
chrome-extension://<extensionID>/<pathToFile>
```

åœ¨ç»å¯¹è·¯å¾„ä¸­ï¼Œ*\<extensionID\>* æ˜¯æ‰©å±•ç³»ç»Ÿä¸ºæ¯ä¸ªæ‰©å±•ç”Ÿæˆçš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚å¯ä»¥é€šè¿‡è½¬åˆ°URL chrome://extensionsæŸ¥çœ‹æ‰€æœ‰åŠ è½½çš„æ‰©å±•çš„idã€‚*\<pathToFile\>* æ˜¯æ–‡ä»¶åœ¨æ‰©å±•åé¡¶çº§æ–‡ä»¶å¤¹ä¸‹çš„ä½ç½®ï¼›å®ƒä¸ç›¸å¯¹è·¯å¾„åŒ¹é…ã€‚
>In the absolute URL, the *\<extensionID\>* is a unique identifier that the extension system generates for each extension. The IDs for all loaded extensions can be viewed by going to the URL **chrome://extensions** . The *\<pathToFile\>* is the location of the file under the extension's top folder; it matches the relative URL.

åœ¨å¤„ç†æœªæ‰“åŒ…çš„æ‰©å±•æ—¶ï¼Œæ‰©å±•æ ‡è¯†å¯ä»¥æ›´æ”¹ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¦‚æœæ‰©å±•æ˜¯ä»ä¸åŒçš„ç›®å½•åŠ è½½çš„ï¼Œåˆ™è§£åŒ…æ‰©å±•çš„IDå°†æ›´æ”¹ï¼›å½“æ‰©å±•è¢«æ‰“åŒ…æ—¶ï¼ŒIDå°†å†æ¬¡æ›´æ”¹ã€‚å¦‚æœæ‰©å±•çš„ä»£ç ä¾èµ–äºç»å¯¹URLï¼Œé‚£ä¹ˆå®ƒå¯ä»¥ä½¿ç”¨chrome.runtime.getURLï¼ˆï¼‰æ–¹æ³•æ¥é¿å…åœ¨å¼€å‘æœŸé—´ç¡¬ç¼–ç IDã€‚
>While working on an unpacked extension the extension ID can change. Specifically, the ID of an unpacked extension will change if the extension is loaded from a different directory; the ID will change again when the extension is packaged. If an extension's code relies on an absolute URL, it can use the **chrome.runtime.getURL()** method to avoid hardcoding the ID during development.

#### æ¶æ„(architecture)

æ‰©å±•çš„ä½“ç³»ç»“æ„å°†å–å†³äºå…¶åŠŸèƒ½ï¼Œä½†è®¸å¤šå¥å£®çš„æ‰©å±•å°†åŒ…æ‹¬å¤šä¸ªç»„ä»¶ï¼š
>An extensionâ€™s architecture will depend on its functionality, but many robust extensions will include multiple components:
- ğŸ“Manifest
- [Background Script](#Background-Script)
- [UI Elements](#UI-Elements)
- [Content Script](#Content-Script)
- [Options Page](#Options-Page)

##### Background Script
**background script** æ˜¯æ‰©å±•çš„äº‹ä»¶å¤„ç†å™¨ï¼›å®ƒåŒ…å«å¯¹æ‰©å±•å¾ˆé‡è¦çš„æµè§ˆå™¨äº‹ä»¶çš„ç›‘å¬å™¨ã€‚å®ƒå¤„äºä¼‘çœ çŠ¶æ€ï¼Œç›´åˆ°äº‹ä»¶è§¦å‘ï¼Œç„¶åæ‰§è¡Œäº‹å…ˆçš„å‘½ä»¤é€»è¾‘ã€‚ä¸€ä¸ªæœ‰æ•ˆçš„åå°è„šæœ¬åªåœ¨éœ€è¦æ—¶åŠ è½½ï¼Œç©ºé—²æ—¶å¸è½½ã€‚
>The background script is the extension's event handler; it contains listeners for browser events that are important to the extension. It lies dormant until an event is fired then performs the instructed logic. An effective background script is only loaded when it is needed and unloaded when it goes idle.

##### UI Elements
**æ‰©å±•çš„ç”¨æˆ·ç•Œ**é¢åº”è¯¥æ˜¯æœ‰æ˜ç¡®ç›®çš„ä¸”æç®€çš„ã€‚ç”¨æˆ·ç•Œé¢åº”è¯¥å®šåˆ¶æˆ–å¢å¼ºæµè§ˆä½“éªŒï¼Œè€Œä¸æ˜¯åˆ†æ•£ç”¨æˆ·çš„æ³¨æ„åŠ›ã€‚å¤§å¤šæ•°æ‰©å±•éƒ½æœ‰**æµè§ˆå™¨æ“ä½œ**æˆ–**é¡µé¢æ“ä½œ**ï¼Œä½†å¯ä»¥åŒ…å«å…¶ä»–å½¢å¼çš„UIï¼Œä¾‹å¦‚**ä¸Šä¸‹æ–‡èœå•**ã€ä½¿ç”¨**omnibox**æˆ–åˆ›å»º**é”®ç›˜å¿«æ·é”®**ã€‚
>An extension's user interface should be purposeful and minimal. The UI should customize or enhance the browsing experience without distracting from it. Most extensions have a browser action or page action, but can contain other forms of UI, such as context menus, use of the omnibox, or creation of a keyboard shortcut.

æ‰©å±•UIé¡µé¢ï¼Œæ¯”å¦‚**å¼¹å‡ºçª—å£**ï¼Œå¯ä»¥åŒ…å«å¸¦æœ‰JavaScripté€»è¾‘çš„æ™®é€šHTMLé¡µé¢ã€‚æ‰©å±•è¿˜å¯ä»¥è°ƒç”¨**tabs.create**æˆ–**window.open()**æ¥æ˜¾ç¤ºæ‰©å±•ä¸­å­˜åœ¨çš„å…¶ä»–HTMLæ–‡ä»¶ã€‚
>Extension UI pages, such as a popup, can contain ordinary HTML pages with JavaScript logic. Extensions can also call tabs.create or window.open() to display additional HTML files present in the extension.

ä½¿ç”¨é¡µé¢æ“ä½œå’Œå¼¹å‡ºçª—å£çš„æ‰©å±•å¯ä»¥ä½¿ç”¨å£°æ˜æ€§å†…å®¹APIåœ¨åå°è„šæœ¬ä¸­ä¸ºç”¨æˆ·æä¾›å¼¹å‡ºçª—å£æ—¶è®¾ç½®è§„åˆ™ã€‚å½“æ¡ä»¶æ»¡è¶³æ—¶ï¼Œåå°è„šæœ¬ä¸å¼¹å‡ºçª—å£é€šä¿¡ï¼Œä½¿å…¶å›¾æ ‡å¯ä¾›ç”¨æˆ·ç‚¹å‡»ã€‚
>An extension using a page action and a popup can use the declarative content API to set rules in the background script for when the popup is available to users. When the conditions are met, the background script communicates with the popup to make itâ€™s icon clickable to users.
![](https://developer.chrome.com/static/images/overview/popuparc.png)
##### Content Script

è¯»å–æˆ–å†™å…¥ç½‘é¡µçš„æ‰©å±•åˆ©ç”¨**content script**ã€‚**content script**åŒ…å«åœ¨å·²åŠ è½½åˆ°æµè§ˆå™¨ä¸­çš„é¡µé¢ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œçš„JavaScriptã€‚**content script**è¯»å–å¹¶ä¿®æ”¹æµè§ˆå™¨è®¿é—®çš„ç½‘é¡µçš„DOMã€‚
>Extensions that read or write to web pages utilize a content script. The content script contains JavaScript that executes in the contexts of a page that has been loaded into the browser. Content scripts read and modify the DOM of web pages the browser visits.

![](https://developer.chrome.com/static/images/overview/contentscriptarc.png)

>**Content scripts**å¯ä»¥é€šè¿‡äº¤æ¢æ¶ˆæ¯å’Œä½¿ç”¨å­˜å‚¨APIå­˜å‚¨å€¼æ¥ä¸å…¶çˆ¶æ‰©å±•è¿›è¡Œé€šä¿¡ã€‚
Content scripts can communicate with their parent extension by exchanging messages and storing values using the storage API.

##### Options Page

æ­£å¦‚æ‰©å±•å…è®¸ç”¨æˆ·è‡ªå®šä¹‰Chromeæµè§ˆå™¨ä¸€æ ·ï¼Œ**options page**ä¹Ÿå…è®¸è‡ªå®šä¹‰æ‰©å±•ã€‚é€‰é¡¹å¯ç”¨äºå¯ç”¨åŠŸèƒ½å¹¶å…è®¸ç”¨æˆ·é€‰æ‹©ä¸å…¶éœ€æ±‚ç›¸å…³çš„åŠŸèƒ½ã€‚
>Just as extensions allow users to customize the Chrome browser, the options page enables customization of the extension. Options can be used to enable features and allow users to choose what functionality is relevant to their needs.

#### Using Chrome APIs

é™¤äº†å¯ä»¥è®¿é—®ä¸webé¡µé¢ç›¸åŒçš„apiä¹‹å¤–ï¼Œæ‰©å±•è¿˜å¯ä»¥ä½¿ç”¨ç‰¹å®šäºæ‰©å±•çš„apiæ¥åˆ›å»ºä¸æµè§ˆå™¨çš„ç´§å¯†é›†æˆã€‚æ‰©å±•å’Œç½‘é¡µéƒ½å¯ä»¥è®¿é—®æ ‡å‡†çš„window.open()æ–¹æ³•æ¥æ‰“å¼€URLï¼Œä½†æ˜¯æ‰©å±•å´(insteadç¿»è¯‘æˆå´åˆé€‚)å¯ä»¥ä½¿ç”¨Chrome API **tabs.create**æ–¹æ³•æŒ‡å®šURLåº”è¯¥æ˜¾ç¤ºåœ¨å“ªä¸ªçª—å£ä¸­ã€‚
>In addition to having access to the same APIs as web pages, extensions can also use extension-specific APIs that create tight integration with the browser. Extensions and webpages can both access the standard window.open() method to open a URL, but extensions can specify which window that URL should be displayed in by using the Chrome API tabs.create method instead.

##### Asynchronous vs. synchronous methods

>å¤§å¤šæ•°Chrome APIæ–¹æ³•éƒ½æ˜¯å¼‚æ­¥çš„ï¼šå®ƒä»¬ä¸éœ€è¦ç­‰å¾…æ“ä½œå®Œæˆå°±ç«‹å³è¿”å›ã€‚å¦‚æœæ‰©å±•éœ€è¦çŸ¥é“å¼‚æ­¥æ“ä½œçš„ç»“æœï¼Œå®ƒå¯ä»¥å°†å›è°ƒå‡½æ•°ä¼ é€’ç»™æ–¹æ³•ã€‚å›è°ƒåœ¨æ–¹æ³•è¿”å›ä¹‹åæ‰§è¡Œï¼Œå¯èƒ½è¦æ™šå¾—å¤šã€‚
Most Chrome API methods are asynchronous: they return immediately without waiting for the operation to finish. If an extension needs to know the outcome of an asynchronous operation it can pass a callback function into the method. The callback is executed later, potentially much later, after the method returns.

å¦‚æœæ‰©å±•éœ€è¦å°†ç”¨æˆ·å½“å‰é€‰å®šçš„é€‰é¡¹å¡å¯¼èˆªåˆ°æ–°çš„URLï¼Œåˆ™éœ€è¦è·å–å½“å‰é€‰é¡¹å¡çš„IDï¼Œç„¶åå°†è¯¥é€‰é¡¹å¡çš„åœ°å€æ›´æ–°ä¸ºæ–°çš„URLã€‚
>If the extension needed to navigate the userâ€™s currently selected tab to a new URL, it would need to get the current tabâ€™s ID and then update that tabâ€™s address to the new URL.

å¦‚æœtabs.queryæ–¹æ³•æ˜¯åŒæ­¥çš„ï¼Œå®ƒå¯èƒ½ç±»ä¼¼äºä¸‹é¢çš„å†…å®¹ã€‚
>If the **tabs.query** method were synchronous, it may look something like below.
```javascript
 //THIS CODE DOESN'T WORK
  var tab = chrome.tabs.query({'active': true}); //WRONG!!!
  chrome.tabs.update(tab.id, {url:newUrl});
  someOtherFunction();
```
æ­¤æ–¹æ³•å°†å¤±è´¥ï¼Œå› ä¸ºqueryï¼ˆï¼‰æ˜¯å¼‚æ­¥çš„ã€‚å®ƒè¿”å›è€Œä¸ä¼šç­‰å¾…å·¥ä½œå®Œæˆï¼Œå¹¶ä¸”æ²¡æœ‰è¿”å›å€¼ã€‚ä¸€ä¸ªæ–¹æ³•åœ¨å¼‚æ­¥å›è°ƒå‚æ•°çš„ç­¾åä¸­æ—¶æ‰æ˜¯å¯ç”¨çš„ã€‚
>This approach will fail because query() is asynchronous. It returns without waiting for the work to complete, and does not return a value. A method is asynchronous when the callback parameter is available in its signature.

```javascript
// Signature for an asynchronous method
  chrome.tabs.query(object queryInfo, function callback)
```
è¦æ­£ç¡®æŸ¥è¯¢é€‰é¡¹å¡å¹¶æ›´æ–°å…¶URLï¼Œæ‰©å±•å¿…é¡»ä½¿ç”¨å›è°ƒå‚æ•°ã€‚
>To correctly query a tab and update its URL the extension must use the callback parameter.
```javascript
//THIS CODE WORKS
  chrome.tabs.query({'active': true}, function(tabs) {
    chrome.tabs.update(tabs[0].id, {url: newUrl});
  });
  someOtherFunction();
```
åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œè¿™äº›è¡ŒæŒ‰ä»¥ä¸‹é¡ºåºæ‰§è¡Œçš„ï¼š1ã€4ã€2ã€‚ç¬¬2è¡Œçš„å›è°ƒå‡½æ•°æŒ‡å®šç»™äº†query()è°ƒç”¨åæ¥æ‰§è¡Œï¼Œä½†ä»…åœ¨å½“å‰é€‰å®šé€‰é¡¹å¡çš„ä¿¡æ¯å¯ç”¨ä¹‹åã€‚è¿™ç§æƒ…å†µä¼šåœ¨query()è¿”å›åå‘ç”Ÿã€‚è™½ç„¶update()æ˜¯å¼‚æ­¥çš„ï¼Œä½†ä»£ç é‡Œæ²¡æœ‰ä½¿ç”¨å›è°ƒå‚æ•°ï¼Œå› ä¸ºæ‰©å±•å¯¹æ›´æ–°çš„ç»“æœä¸(éœ€è¦)åšä»»ä½•äº‹æƒ….
>In the above code, the lines are executed in the following order: 1, 4, 2. The callback function specified to query() is called and then executes line 2, but only after information about the currently selected tab is available. This happens sometime after query() returns. Although update() is asynchronous the code doesnâ€™t use a callback parameter, since the extension doesnâ€™t do anything with the results of the update
```javascript
// Synchronous methods have no callback option and returns a type of string
  string chrome.runtime.getURL()
```
æ­¤æ–¹æ³•ä»¥å­—ç¬¦ä¸²çš„å½¢å¼åŒæ­¥çš„è¿”å›URLï¼Œä¸å†æ‰§è¡Œå…¶ä»–å¼‚æ­¥å·¥ä½œã€‚
>This method synchronously returns the URL as a string and performs no other asynchronous work.

##### More details

äº†è§£æ›´å¤šä¿¡æ¯, è¯·æµè§ˆ **[Chrome API reference docs](https://developer.chrome.com/extensions/api_index)**
>For more information, explore the **[Chrome API reference docs](https://developer.chrome.com/extensions/api_index)**

#### Communication between pages
æ‰©å±•ä¸­çš„ä¸åŒç»„ä»¶ç»å¸¸éœ€è¦ç›¸äº’é€šä¿¡ã€‚ä½¿ç”¨**chrome.extension**æ–¹æ³•ï¼Œå¯ä»¥æ‰¾åˆ°å½¼æ­¤ä¸åŒçš„HTMLé¡µé¢ï¼Œä¾‹å¦‚getViews()å’ŒgetBackgroundPage()ã€‚ä¸€æ—¦ä¸€ä¸ªé¡µé¢å¼•ç”¨äº†å…¶ä»–æ‰©å±•é¡µé¢ï¼Œç¬¬ä¸€ä¸ªé¡µé¢å°±å¯ä»¥è°ƒç”¨å…¶ä»–é¡µé¢ä¸Šçš„å‡½æ•°å¹¶æ“ä½œå®ƒä»¬çš„domã€‚æ­¤å¤–ï¼Œæ‰©å±•çš„æ‰€æœ‰ç»„ä»¶éƒ½å¯ä»¥è®¿é—®ä½¿ç”¨`storage`APIå­˜å‚¨çš„å€¼ï¼Œå¹¶é€šè¿‡`message passing.`è¿›è¡Œé€šä¿¡ã€‚
>Different components in an extension often need to communicate with each other. Different HTML pages can find each other by using the chrome.extension methods, such as getViews() and getBackgroundPage(). Once a page has a reference to other extension pages the first one can invoke functions on the other pages and manipulate their DOMs. Additionally, all components of the extension can access values stored using the storage API and communicate through message passing.

#### Saving data and incognito mode
æ‰©å±•å¯ä»¥ä½¿ç”¨å­˜å‚¨APIã€HTML5 webå­˜å‚¨APIæˆ–é€šè¿‡å‘å‡ºæœåŠ¡å™¨è¯·æ±‚æ¥ä¿å­˜æ•°æ®ã€‚å½“æ‰©å±•éœ€è¦ä¿å­˜æŸäº›å†…å®¹æ—¶ï¼Œé¦–å…ˆè€ƒè™‘å®ƒæ˜¯å¦æ¥è‡ªä¸€ä¸ªæ— ç—•çª—å£ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰©å±•ä¸ä¼šåœ¨æ— ç—•çš„çª—å£ä¸­è¿è¡Œã€‚
>Extensions can save data using the storage API, the HTML5 web storage API , or by making server requests that result in saving data. When the extension needs to save something, first consider if it's from an incognito window. By default, extensions don't run in incognito windows.

æ— ç—•æ¨¡å¼æ‰¿è¯ºçª—å£ä¸ä¼šç•™ä¸‹ä»»ä½•ç—•è¿¹ã€‚å½“å¤„ç†æ¥è‡ªæ— ç—•çª—å£çš„æ•°æ®æ—¶ï¼Œæ‰©å±•åº”è¯¥éµå®ˆè¿™ä¸ªæ‰¿è¯ºã€‚å¦‚æœæ‰©å±•é€šå¸¸ä¿å­˜æµè§ˆå†å²è®°å½•ï¼Œåˆ™ä¸è¦ä¿å­˜æ¥è‡ªæ— ç—•çª—å£çš„å†å²è®°å½•ã€‚ä½†æ˜¯ï¼Œæ‰©å±•å¯ä»¥å­˜å‚¨æ¥è‡ªä»»ä½•çª—å£çš„è®¾ç½®é¦–é€‰é¡¹ï¼Œæ— è®ºæ˜¯å¦æ— ç—•ã€‚
>Incognito mode promises that the window will leave no tracks. When dealing with data from incognito windows, extensions should honor this promise. If an extension normally saves browsing history, don't save history from incognito windows. However, extensions can store setting preferences from any window, incognito or not.

è‹¥è¦æ£€æµ‹çª—å£æ˜¯å¦å¤„äºæ— ç—•æ¨¡å¼ï¼Œè¯·æ£€æŸ¥ç›¸å…³tabs.Tabæˆ–windows.windowå¯¹è±¡çš„â€œåŒ¿åâ€å±æ€§ã€‚
>To detect whether a window is in incognito mode, check the incognito property of the relevant tabs.Tab or windows.Window object.
```javascript
function saveTabData(tab) {
  if (tab.incognito) {
    return;
  } else {
    chrome.storage.local.set({data: tab.url});
  }
}
```